diff --git a/matrix.cpp b/matrix.cpp
index 732ab50..dd6e2b6 100644
--- a/matrix.cpp
+++ b/matrix.cpp
@@ -168,12 +168,16 @@ void matrix_softmax(Matrix& dst, Matrix& src) {
     assert(dst.rows() == src.rows());
     assert(dst.cols() == src.cols());
     for (int col = 0; col < src.cols(); col++) {
+        float max = 0.f;
+        for (int row=0; row<src.rows();row++) {
+            if (src.get(row,col) > max) max = src.get(row,col);
+        }
         float sum = 0.f;
         for (int row = 0; row < src.rows(); row++) {
-            sum += exp(src.get(row,col));
+            sum += exp(src.get(row,col) - max);
         }
         for (int row = 0; row < src.rows(); row++) {
-            dst.set(row, col, exp(src.get(row,col))/sum);
+            dst.set(row, col, exp(src.get(row,col)-max)/sum);
         }
     }
 }
diff --git a/softmax.cuh b/softmax.cuh
index c40ac2c..632316b 100644
--- a/softmax.cuh
+++ b/softmax.cuh
@@ -47,12 +47,50 @@ __device__ __inline__ void softmax_select(int first_col, int num_cols, T* input,
             }
         }
 
-        // Exponentiate and sum
+        float local_max[UNROLL];
         float local_sum[UNROLL];
         for (int u=0; u<UNROLL; u++) {
+            local_max[u] = 0.f;
             local_sum[u] = 0.f;
         }
+
+        // Compute the max first so we can subtract it from the inputs and prevent explosions
+        for (int u=0; u<UNROLL; u++) {
+            for (int r=0; r<ROWS_PER_THREAD; r++) {
+                if (activations_in[u][r] > local_max[u])  local_max[u] = activations_in[u][r];
+            }
+        }
+
+        __shared__ float warp_max[UNROLL][NUM_THREADS/32];
+        for (int u=0; u<UNROLL; u++) {
+            float wmax = local_max[u];
+            for (int offset=16; offset>0; offset /= 2) {
+                float v = __shfl_down_sync(0xFFFFFFFF,wmax,offset);
+                if (v > wmax) wmax = v;
+            }
+            if ((thread_id%32)==0) {
+                warp_max[u][thread_id/32] = wmax;
+            }
+        }
+
+        namedBarrierSync(barrierName, numThreads);
+
+        for (int u=0; u<UNROLL; u++) {
+            for (int w=0; w<NUM_THREADS/32; w++) {
+                float wmax = warp_max[u][w];
+                if (wmax > local_max[u]) local_max[u] = wmax;
+            }
+        }
+
+
+
+        for (int u=0; u<UNROLL; u++) {
+            for (int r=0; r<ROWS_PER_THREAD; r++) {
+                activations_in[u][r] -= local_max[u];
+            }
+        }
        
+        // Exponentiate and sum
 #pragma unroll
         for (int u=0; u<UNROLL; u++) {
             for (int r=0; r<ROWS_PER_THREAD; r++) {
